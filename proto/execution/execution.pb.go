// Code generated by protoc-gen-go. DO NOT EDIT.
// source: execution.proto

package execution

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CommitBlockStatus int32

const (
	// The block is persisted.
	CommitBlockStatus_SUCCEEDED CommitBlockStatus = 0
	// Something went wrong.
	CommitBlockStatus_FAILED CommitBlockStatus = 1
)

var CommitBlockStatus_name = map[int32]string{
	0: "SUCCEEDED",
	1: "FAILED",
}

var CommitBlockStatus_value = map[string]int32{
	"SUCCEEDED": 0,
	"FAILED":    1,
}

func (x CommitBlockStatus) String() string {
	return proto.EnumName(CommitBlockStatus_name, int32(x))
}

func (CommitBlockStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_776e2c5022e94aef, []int{0}
}

type ExecuteBlockRequest struct {
	// The list of transactions from consensus.
	Transactions []*SignedTransaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	// Id of the parent block.
	// We're going to use a special GENESIS_BLOCK_ID constant defined in
	// crypto::hash module to refer to the block id of the Genesis block, which is
	// executed in a special way.
	ParentBlockId []byte `protobuf:"bytes,2,opt,name=parent_block_id,json=parentBlockId,proto3" json:"parent_block_id,omitempty"`
	// Id of the current block.
	BlockId              []byte   `protobuf:"bytes,3,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteBlockRequest) Reset()         { *m = ExecuteBlockRequest{} }
func (m *ExecuteBlockRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteBlockRequest) ProtoMessage()    {}
func (*ExecuteBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_776e2c5022e94aef, []int{0}
}

func (m *ExecuteBlockRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteBlockRequest.Unmarshal(m, b)
}
func (m *ExecuteBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteBlockRequest.Marshal(b, m, deterministic)
}
func (m *ExecuteBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBlockRequest.Merge(m, src)
}
func (m *ExecuteBlockRequest) XXX_Size() int {
	return xxx_messageInfo_ExecuteBlockRequest.Size(m)
}
func (m *ExecuteBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBlockRequest proto.InternalMessageInfo

func (m *ExecuteBlockRequest) GetTransactions() []*SignedTransaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *ExecuteBlockRequest) GetParentBlockId() []byte {
	if m != nil {
		return m.ParentBlockId
	}
	return nil
}

func (m *ExecuteBlockRequest) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

// Result of transaction execution.
type ExecuteBlockResponse struct {
	// Root hash of the ledger after applying all the transactions in this
	// block.
	RootHash []byte `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// The execution result of the transactions. Each transaction has a status
	// field that indicates whether it should be included in the ledger once the
	// block is committed.
	Status []*VMStatus `protobuf:"bytes,2,rep,name=status,proto3" json:"status,omitempty"`
	// The corresponding ledger version when this block is committed.
	Version uint64 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// If set, this field designates that if this block is committed, then the
	// next epoch will start immediately with the included set of validators.
	Validators           *ValidatorSet `protobuf:"bytes,4,opt,name=validators,proto3" json:"validators,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ExecuteBlockResponse) Reset()         { *m = ExecuteBlockResponse{} }
func (m *ExecuteBlockResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteBlockResponse) ProtoMessage()    {}
func (*ExecuteBlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_776e2c5022e94aef, []int{1}
}

func (m *ExecuteBlockResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteBlockResponse.Unmarshal(m, b)
}
func (m *ExecuteBlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteBlockResponse.Marshal(b, m, deterministic)
}
func (m *ExecuteBlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBlockResponse.Merge(m, src)
}
func (m *ExecuteBlockResponse) XXX_Size() int {
	return xxx_messageInfo_ExecuteBlockResponse.Size(m)
}
func (m *ExecuteBlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBlockResponse proto.InternalMessageInfo

func (m *ExecuteBlockResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *ExecuteBlockResponse) GetStatus() []*VMStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ExecuteBlockResponse) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ExecuteBlockResponse) GetValidators() *ValidatorSet {
	if m != nil {
		return m.Validators
	}
	return nil
}

type CommitBlockRequest struct {
	// The ledger info with signatures from 2f+1 validators. It contains the id
	// of the block consensus wants to commit. This will cause the given block
	// and all the uncommitted ancestors to be committed to storage.
	LedgerInfoWithSigs   *LedgerInfoWithSignatures `protobuf:"bytes,1,opt,name=ledger_info_with_sigs,json=ledgerInfoWithSigs,proto3" json:"ledger_info_with_sigs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *CommitBlockRequest) Reset()         { *m = CommitBlockRequest{} }
func (m *CommitBlockRequest) String() string { return proto.CompactTextString(m) }
func (*CommitBlockRequest) ProtoMessage()    {}
func (*CommitBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_776e2c5022e94aef, []int{2}
}

func (m *CommitBlockRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommitBlockRequest.Unmarshal(m, b)
}
func (m *CommitBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommitBlockRequest.Marshal(b, m, deterministic)
}
func (m *CommitBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitBlockRequest.Merge(m, src)
}
func (m *CommitBlockRequest) XXX_Size() int {
	return xxx_messageInfo_CommitBlockRequest.Size(m)
}
func (m *CommitBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CommitBlockRequest proto.InternalMessageInfo

func (m *CommitBlockRequest) GetLedgerInfoWithSigs() *LedgerInfoWithSignatures {
	if m != nil {
		return m.LedgerInfoWithSigs
	}
	return nil
}

type CommitBlockResponse struct {
	Status               CommitBlockStatus `protobuf:"varint,1,opt,name=status,proto3,enum=execution.CommitBlockStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CommitBlockResponse) Reset()         { *m = CommitBlockResponse{} }
func (m *CommitBlockResponse) String() string { return proto.CompactTextString(m) }
func (*CommitBlockResponse) ProtoMessage()    {}
func (*CommitBlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_776e2c5022e94aef, []int{3}
}

func (m *CommitBlockResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommitBlockResponse.Unmarshal(m, b)
}
func (m *CommitBlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommitBlockResponse.Marshal(b, m, deterministic)
}
func (m *CommitBlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitBlockResponse.Merge(m, src)
}
func (m *CommitBlockResponse) XXX_Size() int {
	return xxx_messageInfo_CommitBlockResponse.Size(m)
}
func (m *CommitBlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitBlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommitBlockResponse proto.InternalMessageInfo

func (m *CommitBlockResponse) GetStatus() CommitBlockStatus {
	if m != nil {
		return m.Status
	}
	return CommitBlockStatus_SUCCEEDED
}

// Ask Execution service to execute and commit a chunk of contiguous
// transactions. All the transactions in this chunk should belong to the same
// epoch E. If the caller has a list of transactions that span two epochs, it
// should split the transactions.
type ExecuteChunkRequest struct {
	TxnListWithProof     *TransactionListWithProof `protobuf:"bytes,1,opt,name=txn_list_with_proof,json=txnListWithProof,proto3" json:"txn_list_with_proof,omitempty"`
	LedgerInfoWithSigs   *LedgerInfoWithSignatures `protobuf:"bytes,2,opt,name=ledger_info_with_sigs,json=ledgerInfoWithSigs,proto3" json:"ledger_info_with_sigs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ExecuteChunkRequest) Reset()         { *m = ExecuteChunkRequest{} }
func (m *ExecuteChunkRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteChunkRequest) ProtoMessage()    {}
func (*ExecuteChunkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_776e2c5022e94aef, []int{4}
}

func (m *ExecuteChunkRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteChunkRequest.Unmarshal(m, b)
}
func (m *ExecuteChunkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteChunkRequest.Marshal(b, m, deterministic)
}
func (m *ExecuteChunkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteChunkRequest.Merge(m, src)
}
func (m *ExecuteChunkRequest) XXX_Size() int {
	return xxx_messageInfo_ExecuteChunkRequest.Size(m)
}
func (m *ExecuteChunkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteChunkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteChunkRequest proto.InternalMessageInfo

func (m *ExecuteChunkRequest) GetTxnListWithProof() *TransactionListWithProof {
	if m != nil {
		return m.TxnListWithProof
	}
	return nil
}

func (m *ExecuteChunkRequest) GetLedgerInfoWithSigs() *LedgerInfoWithSignatures {
	if m != nil {
		return m.LedgerInfoWithSigs
	}
	return nil
}

// Either all transactions are successfully executed and persisted, or nothing
// happens.
type ExecuteChunkResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteChunkResponse) Reset()         { *m = ExecuteChunkResponse{} }
func (m *ExecuteChunkResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteChunkResponse) ProtoMessage()    {}
func (*ExecuteChunkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_776e2c5022e94aef, []int{5}
}

func (m *ExecuteChunkResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteChunkResponse.Unmarshal(m, b)
}
func (m *ExecuteChunkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteChunkResponse.Marshal(b, m, deterministic)
}
func (m *ExecuteChunkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteChunkResponse.Merge(m, src)
}
func (m *ExecuteChunkResponse) XXX_Size() int {
	return xxx_messageInfo_ExecuteChunkResponse.Size(m)
}
func (m *ExecuteChunkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteChunkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteChunkResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("execution.CommitBlockStatus", CommitBlockStatus_name, CommitBlockStatus_value)
	proto.RegisterType((*ExecuteBlockRequest)(nil), "execution.ExecuteBlockRequest")
	proto.RegisterType((*ExecuteBlockResponse)(nil), "execution.ExecuteBlockResponse")
	proto.RegisterType((*CommitBlockRequest)(nil), "execution.CommitBlockRequest")
	proto.RegisterType((*CommitBlockResponse)(nil), "execution.CommitBlockResponse")
	proto.RegisterType((*ExecuteChunkRequest)(nil), "execution.ExecuteChunkRequest")
	proto.RegisterType((*ExecuteChunkResponse)(nil), "execution.ExecuteChunkResponse")
}

func init() { proto.RegisterFile("execution.proto", fileDescriptor_776e2c5022e94aef) }

var fileDescriptor_776e2c5022e94aef = []byte{
	// 524 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4d, 0x93, 0xd2, 0x40,
	0x10, 0x25, 0xec, 0x16, 0xbb, 0x34, 0xac, 0xb0, 0xc3, 0x6a, 0x45, 0xd4, 0x5d, 0x2a, 0x07, 0xa5,
	0x3c, 0x70, 0x60, 0x3d, 0x7a, 0x51, 0x88, 0x25, 0x25, 0x6e, 0x69, 0xf0, 0xe3, 0x98, 0x0a, 0x30,
	0x90, 0x29, 0x21, 0x83, 0xd3, 0x0d, 0xe2, 0xd1, 0x3f, 0xe1, 0x9f, 0xf0, 0x17, 0xf8, 0xef, 0xac,
	0x4c, 0x3e, 0x48, 0x56, 0xb8, 0xec, 0x31, 0xaf, 0x5f, 0x5e, 0xbf, 0x7e, 0xdd, 0x09, 0xd4, 0xf8,
	0x96, 0x4f, 0xd6, 0x24, 0x64, 0xd0, 0x59, 0x29, 0x49, 0x92, 0x95, 0x53, 0xa0, 0x79, 0x31, 0xe7,
	0xe4, 0xfe, 0x10, 0xe4, 0xbb, 0x2b, 0x25, 0xe5, 0x2c, 0x22, 0x34, 0xcf, 0x17, 0x7c, 0x3a, 0xe7,
	0xca, 0x15, 0xc1, 0x4c, 0x26, 0x10, 0x29, 0x2f, 0x40, 0x6f, 0xb2, 0x93, 0x69, 0x36, 0x36, 0xde,
	0x42, 0x4c, 0x3d, 0x92, 0xca, 0x45, 0x4e, 0x31, 0x58, 0xdb, 0x2c, 0x5d, 0xae, 0x94, 0x54, 0x18,
	0x01, 0xd6, 0x6f, 0x03, 0x1a, 0xb6, 0xee, 0xc7, 0x5f, 0x2f, 0xe4, 0xe4, 0x9b, 0xc3, 0xbf, 0xaf,
	0x39, 0x12, 0x7b, 0x09, 0xd5, 0x8c, 0x24, 0x9a, 0x46, 0xeb, 0xa8, 0x5d, 0xe9, 0x9a, 0x1d, 0xfa,
	0xb9, 0xe2, 0xd8, 0x19, 0x89, 0x79, 0xc0, 0xa7, 0x9f, 0x76, 0x04, 0x27, 0xc7, 0x66, 0x4f, 0xa1,
	0xb6, 0xf2, 0x14, 0x0f, 0xc8, 0x1d, 0x87, 0xa2, 0xae, 0x98, 0x9a, 0xc5, 0x96, 0xd1, 0xae, 0x3a,
	0x67, 0x11, 0xac, 0x5b, 0x0d, 0xa6, 0xec, 0x21, 0x9c, 0xa6, 0x84, 0x23, 0x4d, 0x38, 0x19, 0x47,
	0x25, 0xeb, 0x8f, 0x01, 0x17, 0x79, 0x63, 0xb8, 0x92, 0x01, 0x72, 0xf6, 0x08, 0xca, 0x4a, 0x4a,
	0x72, 0x7d, 0x0f, 0x7d, 0xd3, 0xd0, 0x2f, 0x9d, 0x86, 0xc0, 0x5b, 0x0f, 0x7d, 0xf6, 0x0c, 0x4a,
	0x48, 0x1e, 0xad, 0xd1, 0x2c, 0x6a, 0xc3, 0xb5, 0xd8, 0xf0, 0x97, 0xf7, 0x23, 0x0d, 0x3b, 0x71,
	0x99, 0x99, 0x70, 0xb2, 0xe1, 0x0a, 0x85, 0x0c, 0x74, 0xe3, 0x63, 0x27, 0x79, 0x64, 0xd7, 0x00,
	0x69, 0x72, 0x68, 0x1e, 0xb7, 0x8c, 0x76, 0xa5, 0xdb, 0x48, 0x64, 0x92, 0xc2, 0x88, 0x93, 0x93,
	0xa1, 0x59, 0x3e, 0xb0, 0x9e, 0x5c, 0x2e, 0x05, 0xe5, 0x42, 0x74, 0xe0, 0x7e, 0x66, 0x55, 0xd1,
	0x22, 0x51, 0xcc, 0x51, 0xdb, 0xae, 0x74, 0xaf, 0x62, 0xd5, 0xa1, 0xe6, 0x0c, 0x82, 0x99, 0xfc,
	0x2a, 0xc8, 0x0f, 0xb3, 0xf5, 0x68, 0xad, 0x38, 0x3a, 0x6c, 0x71, 0xbb, 0x82, 0xd6, 0x3b, 0x68,
	0xe4, 0x3a, 0xc5, 0xa9, 0xbc, 0x48, 0x07, 0x0f, 0xb5, 0xef, 0x75, 0x1f, 0x77, 0x76, 0x67, 0x95,
	0xe1, 0xe7, 0x53, 0xb0, 0xfe, 0xee, 0xb6, 0xdf, 0xf3, 0xd7, 0x41, 0x6a, 0xfc, 0x06, 0x1a, 0xb4,
	0x0d, 0xdc, 0x85, 0xc0, 0xec, 0xf9, 0xdd, 0xb2, 0x9d, 0x59, 0xff, 0x50, 0x20, 0x85, 0x0e, 0x3f,
	0x84, 0x34, 0xa7, 0x4e, 0xdb, 0x3c, 0x72, 0x38, 0x88, 0xe2, 0xdd, 0x83, 0x78, 0x90, 0xde, 0x47,
	0x6c, 0x3d, 0x4a, 0xe2, 0x79, 0x07, 0xce, 0xff, 0x1b, 0x98, 0x9d, 0x41, 0x79, 0xf4, 0xb9, 0xd7,
	0xb3, 0xed, 0xbe, 0xdd, 0xaf, 0x17, 0x18, 0x40, 0xe9, 0xcd, 0xab, 0xc1, 0xd0, 0xee, 0xd7, 0x8d,
	0xee, 0xaf, 0x22, 0x94, 0xed, 0x24, 0x2b, 0xf6, 0x11, 0xaa, 0xd9, 0xab, 0x63, 0x97, 0x99, 0x1c,
	0xf7, 0x7c, 0x27, 0xcd, 0xab, 0x83, 0xf5, 0xc8, 0x8e, 0x55, 0x60, 0x37, 0x50, 0xc9, 0x18, 0x62,
	0x4f, 0xf6, 0x6f, 0x26, 0x11, 0xbc, 0x3c, 0x54, 0x4e, 0xf5, 0x76, 0x16, 0xf5, 0xe0, 0xfb, 0x2c,
	0x66, 0x97, 0xb9, 0xcf, 0x62, 0x2e, 0x31, 0xab, 0x30, 0x2e, 0xe9, 0x9f, 0xc1, 0xf5, 0xbf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x42, 0x4c, 0xdb, 0x04, 0x8c, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExecutionClient is the client API for Execution service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExecutionClient interface {
	// Execute a list of signed transactions given by consensus. Return the id
	// of the block and the root hash of the ledger after applying transactions
	// in this block.
	ExecuteBlock(ctx context.Context, in *ExecuteBlockRequest, opts ...grpc.CallOption) (*ExecuteBlockResponse, error)
	// Commit a previously executed block that has been agreed by consensus.
	CommitBlock(ctx context.Context, in *CommitBlockRequest, opts ...grpc.CallOption) (*CommitBlockResponse, error)
	// Execute and commit a list of signed transactions received from peer
	// during synchronization. Return the id of the block
	ExecuteChunk(ctx context.Context, in *ExecuteChunkRequest, opts ...grpc.CallOption) (*ExecuteChunkResponse, error)
}

type executionClient struct {
	cc *grpc.ClientConn
}

func NewExecutionClient(cc *grpc.ClientConn) ExecutionClient {
	return &executionClient{cc}
}

func (c *executionClient) ExecuteBlock(ctx context.Context, in *ExecuteBlockRequest, opts ...grpc.CallOption) (*ExecuteBlockResponse, error) {
	out := new(ExecuteBlockResponse)
	err := c.cc.Invoke(ctx, "/execution.Execution/ExecuteBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) CommitBlock(ctx context.Context, in *CommitBlockRequest, opts ...grpc.CallOption) (*CommitBlockResponse, error) {
	out := new(CommitBlockResponse)
	err := c.cc.Invoke(ctx, "/execution.Execution/CommitBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) ExecuteChunk(ctx context.Context, in *ExecuteChunkRequest, opts ...grpc.CallOption) (*ExecuteChunkResponse, error) {
	out := new(ExecuteChunkResponse)
	err := c.cc.Invoke(ctx, "/execution.Execution/ExecuteChunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecutionServer is the server API for Execution service.
type ExecutionServer interface {
	// Execute a list of signed transactions given by consensus. Return the id
	// of the block and the root hash of the ledger after applying transactions
	// in this block.
	ExecuteBlock(context.Context, *ExecuteBlockRequest) (*ExecuteBlockResponse, error)
	// Commit a previously executed block that has been agreed by consensus.
	CommitBlock(context.Context, *CommitBlockRequest) (*CommitBlockResponse, error)
	// Execute and commit a list of signed transactions received from peer
	// during synchronization. Return the id of the block
	ExecuteChunk(context.Context, *ExecuteChunkRequest) (*ExecuteChunkResponse, error)
}

// UnimplementedExecutionServer can be embedded to have forward compatible implementations.
type UnimplementedExecutionServer struct {
}

func (*UnimplementedExecutionServer) ExecuteBlock(ctx context.Context, req *ExecuteBlockRequest) (*ExecuteBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteBlock not implemented")
}
func (*UnimplementedExecutionServer) CommitBlock(ctx context.Context, req *CommitBlockRequest) (*CommitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitBlock not implemented")
}
func (*UnimplementedExecutionServer) ExecuteChunk(ctx context.Context, req *ExecuteChunkRequest) (*ExecuteChunkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteChunk not implemented")
}

func RegisterExecutionServer(s *grpc.Server, srv ExecutionServer) {
	s.RegisterService(&_Execution_serviceDesc, srv)
}

func _Execution_ExecuteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).ExecuteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/execution.Execution/ExecuteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).ExecuteBlock(ctx, req.(*ExecuteBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_CommitBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).CommitBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/execution.Execution/CommitBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).CommitBlock(ctx, req.(*CommitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_ExecuteChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).ExecuteChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/execution.Execution/ExecuteChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).ExecuteChunk(ctx, req.(*ExecuteChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Execution_serviceDesc = grpc.ServiceDesc{
	ServiceName: "execution.Execution",
	HandlerType: (*ExecutionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ExecuteBlock",
			Handler:    _Execution_ExecuteBlock_Handler,
		},
		{
			MethodName: "CommitBlock",
			Handler:    _Execution_CommitBlock_Handler,
		},
		{
			MethodName: "ExecuteChunk",
			Handler:    _Execution_ExecuteChunk_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "execution.proto",
}
